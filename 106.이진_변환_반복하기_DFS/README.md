# 이진변환 반복하기(DFS)

0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.

1. x의 모든 0을 제거합니다.
2. x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다.

- 예를 들어, x = "0111010"이라면, x에 이진 변환을 가하면 x = "0111010" -> "1111" -> "100" 이 됩니다.

0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- s의 길이는 1 이상 150,000 이하입니다.
- s에는 '1'이 최소 하나 이상 포함되어 있습니다.

###입출력 예
|s |result|
|---|-----|
|"110010101001"| [3,8]|
|"01110" | [3,3]|
|"1111111" | [4,1]|

### 입출력 예 설명

#### 입출력 예 #1

- "110010101001"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
  |회차 |이진 변환 이전 | 제거할 0의 개수| 0 제거 후 길이| 이진 변환 결과|
  |---|----|----|----|---|
  |1 | "110010101001" | 6| 6| "110"|
  |2 | "110" | 1 | 2 | "10"|
  |3 | "10" | 1| 1 | "1"|
- 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다.

#### 입출력 예 #2

- "01110"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
  |회차 |이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
  |----|-------|-------|------|--------|
  |1 |"01110" | 2 | 3 | "11"|
  |2 |"11" | 0 | 2 | "10"|
  |3 | "10" | 1 | 1 | "1"|
- 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.
  입출력 예 #3

- "1111111"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
  |회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과|
  |----|-------|-------|------|--------|
  |1 |"1111111"| 0| 7| "111"|
  |2| "111" |0| 3| "11"|
  |3| "11"| 0| 2| "10"|
  |4| "10"| 1 |1| "1"|
- 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.

---

## 풀이

```js
function solution(s) {
  var answer = [0, 0];

  // 이진법 변환 재귀함수
  const binary = (num, result = '') => {
    if (Math.floor(num / 2) === 0) {
      return (result += num % 2);
    } else {
      result = binary(Math.floor(num / 2), result);
      result += num % 2;
      return result;
    }
  };
  // 전체 흐름 반복 재귀함수
  const dfs = (s) => {
    if (String(s) === '1') return;
    else {
      answer[0]++;
      let strWithout0 = '';
      [...s].forEach((c) => {
        if (c === '0') {
          answer[1]++;
        } else {
          strWithout0 += c;
        }
      });
      const result = binary(Number(strWithout0.length));
      dfs(result);
    }
  };
  dfs(s);
  return answer;
}

console.log(solution('0111010'));
```

- 재귀함수로 해결
- 재귀함수의 역할은 다음과 같이 정리

  1. 회차 카운팅
  2. 0의 개수 카운팅
  3. 문자열에서 0 제거
  4. 0이 제거된 문자열의 개수를 이진수로 변환
  5. 이진수 반환

- 4번의 이진수 변환도 재귀함수로 선언
- 시간 복잡도... 재귀에 재귀...라서 구하기 어렵다. 
- 재귀: O(분기^깊이)
  - 이진변환 함수에서의 시간 복잡도는 O(1^n)
  - 메인 깊이우선탐색 함수에서의 시간 복잡도는 O(1^n)

### 고수들 풀이

```js
function solution(s) {
  var answer = [0, 0];
  while (s.length > 1) {
    answer[0]++; // 회사 카운팅
    answer[1] += (s.match(/0/g) || []).length; // 0의 개수 카운팅
    s = s.replace(/0/g, '').length.toString(2);
  }
  return answer;
}
```

- javascript의 `Object.prototype.toString()`은 매개변수를 받을 경우 해당 진수로 변환해준다... 
- 반복문의 역할을 정규표현식이 대신한다.
- 물론 `match` 또는 `replace` 의 함수 내부에서 반복문을 돌리겠지만, 현재 보이는 코드로는 시간 복잡도 O(n)
